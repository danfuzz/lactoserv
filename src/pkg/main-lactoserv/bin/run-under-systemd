#!/bin/bash
#
# Copyright 2022 the Lactoserv Authors (Dan Bornstein et alia).
# This project is PROPRIETARY and UNLICENSED.

#
# Helper for running under `systemd`: Manages a `lactoserv` process, or (for
# development) runs it in the foreground.
#

# Figure out the symlink-resolved program name and directory.
cmdName="$(readlink -f "$0")" || exit "$?"
cmdDir="${cmdName%/*}"
cmdName="${cmdName##*/}"
baseDir="${cmdDir%/*}"


#
# Argument parsing.
#

function usage {
    echo 1>&2 'Usage:'
    echo 1>&2 "  ${cmdName} run-foreground <server-arg> ..."
    echo 1>&2 "  ${cmdName} --service-name=<name> start <server-arg> ..."
    echo 1>&2 "  ${cmdName} --service-name=<name> reload"
    echo 1>&2 "  ${cmdName} --service-name=<name> stop"
    exit 1
}

# Command.
command=''

# Service name.
serviceName=''

# Arguments to pass through when starting the server.
serverArgs=()

while (( $# != 0 )); do
    case "$1" in
        --service-name=*)
            serviceName="${1#*=}"
            ;;
        --)
            # Explicit end of options.
            shift
            break
            ;;
        -?*)
            echo 1>&2 "Unknown option: $1"
            usage
            ;;
        *)
            # Non-option argument.
            break
            ;;
    esac

    shift
done

if (( $# == 0 )); then
    echo 1>&2 'Missing command.'
    usage
fi

command="$1"
shift

if [[ ${command} =~ ^(run-foreground|start)$ ]]; then
    if (( $# == 0 )); then
        echo 1>&2 'Server arguments required when starting service.'
        usage
    fi
    serverArgs=("$@")
else
    if (( $# != 0 )); then
        echo 1>&2 'Server arguments not allowed when manipulating a running service.'
        usage
    fi
fi

if [[ (${command} != 'run-foreground') && (${serviceName} == '') ]]; then
    echo 1>&2 "Option --service-name required for command: ${command}"
    usage
fi


#
# Helper functions
#

# Runs the system in the foreground.
function do-run-foreground {
    exec "${runCmd}" --log-to-stdout "${serverArgs[@]}"
}

# Starts the system, daemon-style.
function do-start {
    local fullCommand=("${runCmd}" "${serverArgs[@]}")

    # Write the command about to be executed to the log. Note: In a typical OS
    # configuration, the service-specific log can be seen with `journalctl
    # --unit=<service-name>`, where <service-name> is the name of the systemd
    # service that runs this command, e.g. probably `lactoserv` or some variant
    # thereof.
    echo 1>&2 'Running server via command:'
    printf 1>&2 '  %q' "${fullCommand[@]}"

    # Note: `exec` is required so that the process running this script
    # ultimately becomes the process actually running the service. (If that
    # turns out not to be the case, then the `systemd` configuration will need
    # to be adjusted.)
    exec "${fullCommand[@]}"
}

# Tells a daemon that's running to reload.
function do-reload {
    local pid

    pid="$(get-service-pid)" \
    || return "$?"

    kill -HUP "${pid}"
}

# Stops a daemon that's running.
function do-stop {
    local pid

    pid="$(get-service-pid)" \
    || return "$?"

    kill "${pid}"
}

# Gets the main PID for the given service.
function get-service-pid {
    local result

    result="$(systemctl show --property=MainPID "${serviceName}")" \
    || return "$?"

    if [[ ${result} =~ ^MainPID=(.*)$ ]]; then
        echo "${BASH_REMATCH[1]}"
    else
        printf 1>&2 'Strange output: %q\n' "${result}"
        return 1
    fi
}


#
# Main script
#

runCmd="${cmdDir}/run"
commandFunc="do-${command}"

if ! declare -F "${commandFunc}" >/dev/null; then
    echo 1>&2 "Unknown command: ${command}"
    usage
fi

"${commandFunc}" || exit "$?"
