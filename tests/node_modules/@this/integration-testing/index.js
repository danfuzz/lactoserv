// Copyright 2022-2024 the Bashy-lib Authors (Dan Bornstein et alia).
// SPDX-License-Identifier: Apache-2.0

export async function checkResponse(responsePromise, config) {
  const response = await responsePromise;

  console.log('### Metadata');
  console.log('');

  let anyErrors = false;

  if (response.status !== config.status) {
    console.log('* Status: got %s, expected %s', response.status, config.status);
    anyErrors = true;
  }

  if (response.statusText !== config.statusText) {
    console.log('* Status text: got %s, expected %s', response.statusText, config.statusText);
    anyErrors = true;
  }

  const gotHeaders = new Map(response.headers.entries());
  for (const [name, value] of Object.entries(config.headers)) {
    const got = gotHeaders.get(name);
    gotHeaders.delete(name);

    if (got === undefined) {
      console.log('* Header %s: missing', name);
      anyErrors = true;
    } else if (typeof value === 'string') {
      if (got !== value) {
        console.log('* Header %s', name);
        console.log('  * got %o', got);
        console.log('  * expected %o', value);
        anyErrors = true;
      }
    } else {
      if (!new RegExp(value).test(got)) {
        console.log('* Header %s', name);
        console.log('  * got %o', got);
        console.log('  * expected match /%s/', value);
        anyErrors = true;
      }
    }
  }

  for (const [name, value] of gotHeaders.entries()) {
    console.log('* Header %s', name);
    console.log('  * got %o', value);
    console.log('  * unexpected');
    anyErrors = true;
  }

  if (!anyErrors) {
    console.log('* No problems.');
  }

  console.log('');
  console.log('### Body');
  console.log('');

  const gotBody = response.body ? await response.text() : null;
  const bodyCheck = config.body ?? null;

  const printBody = () => {
    if (gotBody) {
      console.log('```\n%s```', gotBody);
    } else {
      console.log('(no body)');
    }
  };

  if (bodyCheck === null) {
    printBody();
  } else {
    if (!gotBody) {
      console.log('Missing body.');
    } else if (typeof bodyCheck === 'string') {
      if (gotBody !== bodyCheck) {
        console.log('Non-matching body.\n');
        printBody();
      } else {
        console.log('Body is as expected.');
      }
    } else {
      if (!new RegExp(bodyCheck).test(gotBody)) {
        console.log('Non-matching body.\n');
        printBody();
      } else {
        console.log('Body is as expected.');
      }
    }
  }
}

let firstRequest = true; // First call to `requestAndCheck()`?

export async function requestAndCheck(label, requestOptions, checkOptions) {
  if (firstRequest) {
    firstRequest = false;
  } else {
    console.log('');
  }

  console.log(`## ${label}\n`);

  // Note: `url` is an argument, not an option, in the `fetch()` world.
  const { url, ...moreRequestOptions } = requestOptions;

  // Provide default options that make our tests easier to write. E.g., most of
  // the time we don't want to follow redirects.

  const finalRequestOptions = {
    //cache:    'reload',
    //keepalive: false,
    redirect:  'manual',
    //referrer:  'no-referrer',
    ...moreRequestOptions
  };

  for (const [k, v] of Object.entries(finalRequestOptions)) {
    if (v === null) {
      delete finalRequestOptions[k];
    }
  }

  // Make the request!

  let response;
  try {
    response = await fetch('http://localhost:8080/', finalRequestOptions);
  } catch (e) {
    console.log('### Error during fetch:\n%o', e);
    return;
  }

  // Check it.

  await checkResponse(response, checkOptions);
}
