// Copyright 2022-2024 the Bashy-lib Authors (Dan Bornstein et alia).
// SPDX-License-Identifier: Apache-2.0

/**
 * Merges configs / expectations.
 */
function mergeConfigs(fromCaller, underlay) {
  const result = {
    ...underlay,
    ...fromCaller,

    headers: {
      ...underlay.headers,
      ...fromCaller.headers
    }
  };

  for (const [k, v] of Object.entries(result)) {
    if (v === null) {
      delete result[k];
    }
  }

  for (const [k, v] of Object.entries(result.headers)) {
    if (v === null) {
      delete result.headers[k];
    }
  }

  return result;
}

// Checks a `fetch()` response against a given set of expectations. Note: Some
// default values are provided to keep the test cases DRYer, but they can be
// overridden with values or by `null` to not include them at all.
export async function checkResponse(responsePromise, expected) {
  const response = await responsePromise;

  expected = mergeConfigs(expected, {
    headers: {
      'connection': /^keep-alive$/,
      'date':       /^[ ,:0-9A-Za-z]+ GMT$/,
      'server':     /^lactoserv-[.0-9]+ [0-9a-f]+$/
    }
  });

  console.log('### Metadata');
  console.log('');

  let anyErrors = false;

  if (response.status !== expected.status) {
    console.log('* Status: got %s, expected %s', response.status, expected.status);
    anyErrors = true;
  }

  if (response.statusText !== expected.statusText) {
    console.log('* Status text: got %s, expected %s', response.statusText, expected.statusText);
    anyErrors = true;
  }

  const gotHeaders = new Map(response.headers.entries());
  for (const [name, value] of Object.entries(expected.headers)) {
    const got = gotHeaders.get(name);
    gotHeaders.delete(name);

    if (got === undefined) {
      console.log('* Header %s: missing', name);
      anyErrors = true;
    } else if (typeof value === 'string') {
      if (got !== value) {
        console.log('* Header %s', name);
        console.log('  * got %o', got);
        console.log('  * expected %o', value);
        anyErrors = true;
      }
    } else if (value instanceof RegExp) {
      if (!value.test(got)) {
        console.log('* Header %s', name);
        console.log('  * got %o', got);
        console.log('  * expected match %s', value);
        anyErrors = true;
      }
    } else {
      throw new Error(`Weird header matcher: ${value}`);
    }
  }

  for (const [name, value] of gotHeaders.entries()) {
    console.log('* Header %s', name);
    console.log('  * got %o', value);
    console.log('  * unexpected');
    anyErrors = true;
  }

  if (!anyErrors) {
    console.log('* No problems.');
  }

  console.log('');
  console.log('### Body');
  console.log('');

  const gotBody = response.body ? await response.text() : null;
  const bodyCheck = expected.body ?? null;

  const printBody = () => {
    if (gotBody) {
      console.log('```\n%s```', gotBody);
    } else {
      console.log('(no body)');
    }
  };

  if (bodyCheck === null) {
    printBody();
  } else {
    if (!gotBody) {
      console.log('Missing body.');
    } else if (typeof bodyCheck === 'string') {
      if (gotBody !== bodyCheck) {
        console.log('Non-matching body.\n');
        printBody();
      } else {
        console.log('Body is as expected.');
      }
    } else if (bodyCheck instanceof RegExp) {
      if (!new RegExp(bodyCheck).test(gotBody)) {
        console.log('Non-matching body.\n');
        console.log('* expected match %s', bodyCheck);
        printBody();
      } else {
        console.log('Body is as expected.');
      }
    } else {
      throw new Error(`Weird body matcher: ${value}`);
    }
  }
}

// `fetch()` but with some options set with defaults that make more sense for
// things while testing, and with `url` as an option instead of a separate
// argument.
export async function usualFetch(options) {
  const { url, ...finalOptions } = mergeConfigs(options, {
    redirect: 'manual',
    //referrer: 'no-referrer',

    headers: {
      // If we don't add a `cache-control` header, Node automatically adds
      // `cache-control: no-cache`, which is defined to make conditional requests
      // always fail. Since many of these tests test exactly that sort of
      // functionality, we err on the side of providing a header that allows
      // those tests to work, and let tests override it as needed.
      'cache-control': 'max-age=0'

      // We don't want to end up with the server telling us to `keep-alive`. But
      // as of this writing, specifying this causes some strife on the server.
      // TODO: Look into this!
      //'connection': 'close'
    }
  });

  return await fetch(url, finalOptions);
}

let firstRequest = true; // First call to `requestAndCheck()`?

export async function requestAndCheck(label, requestOptions, checkOptions) {
  if (firstRequest) {
    firstRequest = false;
  } else {
    console.log('');
  }

  console.log(`## ${label}\n`);

  let response;
  try {
    response = await usualFetch(requestOptions);
  } catch (e) {
    console.log('### Error during `fetch()`:\n%o', e);
    return;
  }

  // Check it.

  await checkResponse(response, checkOptions);

  // In case later cases want to peek into this response.
  return response;
}
