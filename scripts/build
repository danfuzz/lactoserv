#!/bin/bash
#
# Copyright 2022 Dan Bornstein. All rights reserved.
# All code and assets are considered proprietary and unlicensed.

. "$(dirname "$(readlink -f "$0")")/lib/init.sh" || exit "$?"

#
# Argument parsing
#

function usage {
    print-usage $'
    Usage:

    ${name} [<opt> ...]
      Builds the project.

    --clean
      Do a clean build.
    --out=<dir>
      Directory where built output goes. Defaults to `out` directly under the
      main product directory.

    ${name} [--help | -h]
      Displays this message.
    '

    exit "$@"
}

# Want help?
opt-action --call='{ usage }' help/h

# Clean build?
opt-toggle --var=doClean clean

# Built output directory.
opt-value --var=outDir out

process-args "$@" || usage "$?"


#
# Helper functions
#

# Fills in the `<hash>`es of the given local package set, based on the contents
# of the package JSON files.
function local-packages-fill-in-hashes {
    local localPackageSet="$1"

    local jsonFiles=($(jget --output=raw "${localPackageSet}" '.[] | .destJsonFile'))
    local f
    for f in "${jsonFiles[@]}"; do
        jget --file="${f}" \
            '{
                name: (.name | sub("^@[^/]+/(?<name>.*)$"; .name)),
                hash: .shasum[0:20]
            }'
    done \
    | jval --input=slurp result:json="${localPackageSet}" \
        'reduce .[] as $item ($result;
            .[$item.name].destPkgFile =
                (.[$item.name].destPkgFile | sub("<hash>"; $item.hash))
            |
            .[$item.name].destPkgUri =
                (.[$item.name].destPkgUri | sub("<hash>"; $item.hash))
        )'
}

# Gets the set of local packages, as a JSON object mapped from name to info
# objects. The result leaves the destination package file with a `<hash>` hole
# to be filled in.
function local-packages {
    local pkgDirName='local-pkg'
    local pkgSrcDir="${srcDir}/pkg"
    local srcPaths

    srcPaths=($(
        find "${pkgSrcDir}" -mindepth 2 -maxdepth 2 -name package.json \
            -exec dirname '{}' ';' \
            | sort
        ))

    (
        local p
        for p in "${srcPaths[@]}"; do
            jval \
                outDir="${outDir}" \
                pkgDirName="${pkgDirName}" \
                name="$(basename "${p}")" \
                srcPath="${p}" \
                '
                ($pkgDirName + "/" + $name) as $nameBase
                |
                ($nameBase + "-<hash>.tgz") as $pkgFile
                |
                {
                    ($name): {
                        name:         $name,
                        scopedName:   ("@this/" + $name),
                        srcPath:      $srcPath,
                        destDir:      ($outDir + "/" + $pkgDirName),
                        destJsonFile: ($outDir + "/" + $nameBase + ".json"),
                        destPkgFile:  ($outDir + "/" + $pkgFile),
                        destPkgUri:   ("file:" + $pkgFile)
                    }
                }'
        done
    ) | jval --input=slurp 'reduce .[] as $item ({}; . + $item)'
}

# Packs all the local packages.
function pack-local-packages {
    local localPackageSet="$1"

    local allNames=($(jget --output=raw "${localPackageSet}" 'keys | .[]'))
    local n
    for n in "${allNames[@]}"; do
        progress-msg "Packing local package ${n}..."

        local paths="$(jget "${localPackageSet}" name="${n}" '.[$name]')"
        local destDir="$(jget --output=raw "${paths}" '.destDir')"

        mkdir -p "${destDir}" || return "$?"

        cd "$(jget --output=raw "${paths}" '.srcPath')"

        local packageInfo
        packageInfo="$(npm pack --json --pack-destination="${destDir}")" \
        || exit "$?"

        # The JSON output from `npm pack` is wrapped in a top-level array
        # (because some invocations can emit multiple packages), but it's
        # superfluous here, so we unwrap with `.[0]`.
        packageInfo="$(jget "${packageInfo}" '.[0]')"

        cat <<<"${packageInfo}" >"$(jget --output=raw "${paths}" '.destJsonFile')"
    done
}

# Renames the local packages to their designated hash-based name.
function rename-local-packages {
    local localPackageSet="$1"

    local allNames=($(jget --output=raw "${localPackageSet}" 'keys | .[]'))
    local n
    for n in "${allNames[@]}"; do
        progress-msg "Moving local package ${n}..."

        local paths="$(jget "${localPackageSet}" name="${n}" '.[$name]')"
        local pkgFrom="$(jget --output=raw "${paths}" '.destDir')/"

        pkgFrom+="$(jget --output=raw \
            --file="$(jget --output=raw "${paths}" '.destJsonFile')" \
            '
            .filename
            |
            sub("^@(?<scope>[^/]+)/(?<name>.*)$"; .scope + "-" + .name)
            '
        )"

        mv "${pkgFrom}" "$(jget --output=raw "${paths}" '.destPkgFile')" \
        || return "$?"
    done
}

# Sets up the output directory.
function set-up-out-dir {
    local extraOpts=()
    if (( doClean )); then
        extraOpts=(--remove)
    fi

    lib out-dir --out="${outDir}" --create --print "${extraOpts[@]}"
}

#
# Main script
#

progress-msg --enable

baseDir="$(dirname "$(this-cmd-dir)")"
srcDir="${baseDir}/src"
etcDir="${baseDir}/etc"
outDir="$(set-up-out-dir)"

# Copy the top-level code.
(
    progress-msg 'Copying top-level code...'
    cd "${srcDir}"
    find . -name pkg -prune -o -type f -name '*.js' -exec \
        cp '{}' "${outDir}/{}" ';'
)

# Create package tarballs of each local package, and also gather up all the info
# for putting in the top-level `dependencies`.

localPackageSet="$(local-packages)" \
|| exit "$?"

pack-local-packages "${localPackageSet}" \
|| exit "$?"

localPackageSet="$(local-packages-fill-in-hashes "${localPackageSet}")" \
|| exit "$?"

rename-local-packages "${localPackageSet}" \
|| exit "$?"

# Derive the `dependencies` to use in the top-level `package.json` to represent
# the local packages.
localDepsObj="$(json-get "${localPackageSet}" \
    'with_entries(.key = .value.scopedName | .value = .value.destPkgUri)'
)"

# Save the local package info for ease of human reference.
cat <<<"${localPackageSet}" >"${outDir}/local-pkg.json"

# Copy over main `package.json`, adding the local package dependencies.
jget >"${outDir}/package.json" \
    --file="${srcDir}/package.json" \
    deps:json="${localDepsObj}" \
    '.dependencies += $deps'

# Let `npm` do its thing.
progress-msg 'Fetching and installing dependencies...'
cd "${outDir}"
npm install --omit=dev \
|| exit "$?"

# Copy over the script binaries.
progress-msg 'Copying script binaries...'
mkdir -p "${outDir}/bin"
cd "${etcDir}/bin-src"
find . -type f \
    -exec cp '{}' "${outDir}/bin/{}" ';' \
    -exec chmod 755 "${outDir}/bin/{}" ';' \
|| exit "$?"

# Clean things up a bit.

# Remove defunct package info files. Kinda cheesy: Take the list of currently-
# valid names and the list of all the ones that are in the package output
# directory, and remove all of the names that don't appear twice.
defunct=($(
    (
        printf '%s\n' "${localPackages[@]}"
        find "${packageDestDir}" -name '*.json' -exec basename '{}' '.json' ';'
    ) | sort | uniq -c | awk '$1 != 2 { print $2 }'
))
for d in "${defunct[@]}"; do
    progress-msg "Removing defunct local package info for ${d}..."
    rm -f "${packageDestDir}/${d}.json"
done

# Remove defunct local package `tgz` files. Similar -- and similarly cheesy --
# logic to the package info file cleanup above.
defunct=($(
    (
        for p in "${localPackages[@]}"; do
            jget --file="${packageDestDir}/${p}.json" --output=raw '.hashname'
        done
        find "${packageDestDir}" -name '*.tgz' -exec basename '{}' ';'
    ) | sort | uniq -c | awk '$1 != 2 { print $2 }'
))
for d in "${defunct[@]}"; do
    progress-msg "Removing defunct local package ${d}..."
    rm -f "${packageDestDir}/${d}"
done

progress-msg
progress-msg 'Build complete!'
