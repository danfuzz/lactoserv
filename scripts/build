#!/bin/bash
#
# Copyright 2022 Dan Bornstein. All rights reserved.
# All code and assets are considered proprietary and unlicensed.

. "$(dirname "$(readlink -f "$0")")/lib/init.sh" || exit "$?"

#
# Argument parsing
#

function usage {
    print-usage $'
    Usage:

    ${name} [<opt> ...]
      Builds the project.

    --clean
      Do a clean build.
    --out=<dir>
      Directory where built output goes. Defaults to `out` directly under the
      main product directory.

    ${name} [--help | -h]
      Displays this message.
    '

    exit "$@"
}

# Want help?
opt-action --call='{ usage }' help/h

# Clean build?
opt-toggle --var=doClean clean

# Built output directory.
opt-value --var=outDir out

process-args "$@" || usage "$?"


#
# Helper functions
#

# Build a JS project from a particular "main" local module.
function build-js-project {
    local projectName="$1"
    local mainModule="$2"
    local destDir="${outDir}/${projectName}"
    local localCodeDirName='code'
    local destLocalCode="${destDir}/${localCodeDirName}"
    local destLocalModules="${destLocalCode}/node_modules"

    progress-msg "Building JS project ${projectName}..."
    progress-msg "Main module: ${mainModule}"

    mkdir -p "${destLocalModules}" \
    || return "$?"

    # Figure out local vs. external dependencies.

    progress-msg 'Determining local and external dependencies...'

    local deps
    deps="$(lib find-module-dependencies "${mainModule}")" \
    || return "$?"

    # Construct a top-level package.json.

    progress-msg 'Making `package.json`...'

    jget >"${destDir}/package.json" \
        --file="${srcDir}/pkg/${mainModule}/package.json" \
        localCodeDirName="${localCodeDirName}" \
        deps:json="${deps}" \
        projectName="${projectName}" '
    . | del(.imports) +
    {
        name:         ("top-of-" + $projectName),
        dependencies: $deps.extDeps,
        exports:      ("./" + $localCodeDirName + "/index.js")
    }' \
    || return "$?"

    # Write a top-level `index.js`.

    progress-msg 'Making `index.js`...'

    (
        for (( n = 0; n < 10; n++ )); do
            echo "// FILE GENERATED BY SCRIPT \`$(this-cmd-name)\`. DO NOT EDIT!"
        done
        echo ''
        echo "import { default as main } from '@this/${mainModule}';"
        echo ''
        echo 'await main();'
        echo ''
        echo '// `main()` is not expected to ever return.'
        echo $'throw new Error(\'Shouldn\\\'t happen.\');'
    ) > "${destLocalCode}/index.js"

    # Copy all the local modules.
    #
    # Note: The `jget` command outputs an `eval`able script to perform the
    # copies.

    progress-msg 'Copying local modules...'

    local moduleFromDir="${srcDir}/pkg"
    local copyCmd
    copyCmd="$(
        jget --output=raw "${deps}" \
            cmd='rsync-archive' \
            fromDir="${moduleFromDir}" \
            toDir="${destLocalModules}" '
        .localDeps
        |
        map({
                fromPath: ($fromDir + "/" + (. | sub("^[^/]*/"; "") + "/") | @sh),
                toPath:   ($toDir + "/" + . | @sh)
            }
            |
            "mkdir -p " + .toPath,
            $cmd + " " + .fromPath + " " + .toPath
            |
            "&& " + . + " \\"
        )
        |
        ["true \\"] + . + ["&& true"]
        |
        join("\n")
        '
    )" \
    || return "$?"

    eval "${copyCmd}"

    # Remove local module directories that are no longer part of the build.

    local deadModules
    deadModules="$(
        cd "${destLocalModules}"
        json-find . -mindepth 2 -maxdepth 2 -type d -printjson \
        | jval --input=slurp \
            deps:json="${deps}" \
            'map(ltrimstr("./")) - $deps.localDeps'
    )" \
    || return "$?"

    if [[ ${deadModules} != '[]' ]]; then
        # As with the module copying above, this works by generating a script to
        # perform the removals.
        local removalCmd
        removalCmd="$(
            jval \
                --output=raw \
                destDir="${destLocalModules}" \
                deadModules:json="${deadModules}" '
            $deadModules
            |
            map(
                "progress-msg " + ("  " + . | @sh),
                "rm -rf " + ($destDir + "/" + . | @sh)
                |
                "&& " + . + " \\"
            )
            |
            ["true \\"] + . + ["&& true"]
            |
            join("\n")
        ')"

        progress-msg 'Removing defunct local modules:'
        eval "${removalCmd}"
        progress-msg
    fi

    # Run `npm install`.

    progress-msg 'Fetching and installing external dependencies...'

    (
        # TODO: Figure out how to run safely. (E.g. fetch first and then run the
        # actual install in an environment with no networking.)
        cd "${destDir}"
        npm install --no-fund --omit=dev
    ) \
    || return "$?"

    # Run the "suspect files" checker.

    progress-msg 'Checking for platform agnosticity...'
    suspect-file-check "${destDir}/node_modules"
}

# Copies all the top-level `bin` scripts into the out directory.
function build-top-bin {
    progress-msg 'Building top-level `bin` directory...'

    rm -rf "${outDir}/bin" || return "$?"
    mkdir -p "${outDir}/bin" || return "$?"

    (
        cd "${etcDir}/bin-src"
        find . -type f '!' -name '*.md' \
            -exec cp '{}' "${outDir}/bin/{}" ';' \
            -exec chmod 755 "${outDir}/bin/{}" ';'
    ) \
    || return "$?"
}

# Like `find`, but with an extra "primary" `-printjson` which is like `-print`
# except that it outputs JSON strings. This notably makes it safe for use with
# file names that have spaces in them.
function json-find {
    local jsonArray="$(lib --path json-array)"
    local args=()
    local arg

    for arg in "$@"; do
        if [[ ${arg} == '-printjson' ]]; then
            args+=(-exec "${jsonArray}" --input=strings '{}' '+')
        else
            args+=("${arg}")
        fi
    done

    find "${args[@]}" | jval --input=read '.[]'
}

# Calls `rsync` so as to do an all-local (not actually remote) "archive" copy
# (preserving permissions, modtimes, etc.).
#
# Note: We use `rsync` and not `cp` (even though this is a totally local
# operation) because it has well-defined behavior when copying a tree on top of
# another tree and also knows how to create directories as needed.
#
# Note: Trailing slashes on source directory names are significant to `rsync`.
# This may be salient at some of the use sites.
function rsync-archive {
    # Prepend `./` to any argument that could be mistaken for a remote path
    # (i.e., when there's a `:` before the first `/`).
    local args=()
    local arg
    for arg in "$@"; do
        if [[ ${arg} =~ ^[^/]+: ]]; then
            args+=("./${arg}")
        else
            args+=("${arg}")
        fi
    done

    # **Note:** We turn off file-sameness checking, which is irrelevant for this
    # use and is furthermore counterproductive, in that it can cause a failure
    # to copy when two non-identical files happen to match in both size and
    # timestamp. (This has happened in practice. When running a build on a
    # freshly checked-out source tree, many many files have the same timestamps,
    # so only the file sizes come into play, and it's very easy to have a file
    # size coincidence.)
    rsync --archive --delete --ignore-times -- "${args[@]}"
}

# Sets up the output directory.
function set-up-out-dir {
    local extraOpts=()
    if (( doClean )); then
        extraOpts=(--remove)
    fi

    lib out-dir --out="${outDir}" --create --print "${extraOpts[@]}"
}

# Checks a `node_modules` directory (or similar) for "suspect" files, given a
# desire to have a platform-agnostic build.
function suspect-file-check {
    local dir="$1"

    suspectFiles="$(
        cd "${dir}"
        find . -type f \
            '!' '(' \
                -name '*.js' -o -name '*.json' -o -name '*.html' -o -name '*.md' \
            ')' \
            -exec file '{}' ';' \
        | grep -Ev 'ASCII|JSON|PNG|UTF-8|empty|short file' \
        | awk '{ sub(/^\.\//, "  "); sub(/:[ \t].*$/, ""); print; }'
    )"

    if [[ ${suspectFiles} != '' ]]; then
        error-msg 'Files possibly containing platform-specific binaries:'
        error-msg -- "${suspectFiles}"
        return 1
    fi
}


#
# Main script
#

progress-msg --enable

baseDir="$(dirname "$(this-cmd-dir)")"
srcDir="${baseDir}/src"
etcDir="${baseDir}/etc"
outDir="$(set-up-out-dir)"
outCodeDir="${outDir}/code"

# Make sure there's a cert to use.
lib make-localhost-cert \
|| exit "$?"

build-top-bin \
|| exit "$?"

# Copy over the example setup.
progress-msg 'Copying example setup...'
(
    rm -rf "${outDir}/etc/example-setup"
    mkdir -p "${outDir}/etc"
    cp -r "${etcDir}/example-setup" "${outDir}/etc"
) \
|| exit "$?"

build-js-project lactoserv main \
|| exit "$?"

progress-msg
progress-msg 'Build complete!'
