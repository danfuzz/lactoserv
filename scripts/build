#!/bin/bash
#
# Copyright 2022 Dan Bornstein. All rights reserved.
# All code and assets are considered proprietary and unlicensed.

. "$(dirname "$(readlink -f "$0")")/lib/init.sh" || exit "$?"

#
# Argument parsing
#

function usage {
    print-usage $'
    Usage:

    ${name} [<opt> ...]
      Builds the project.

    --clean
      Do a clean build.
    --new
      Use the new JS build code. TODO: Get rid of the old way!
    --out=<dir>
      Directory where built output goes. Defaults to `out` directly under the
      main product directory.

    ${name} [--help | -h]
      Displays this message.
    '

    exit "$@"
}

# Want help?
opt-action --call='{ usage }' help/h

# Clean build?
opt-toggle --var=doClean clean

# New-style build?
opt-toggle --var=doNew new

# Built output directory.
opt-value --var=outDir out

process-args "$@" || usage "$?"


#
# Helper functions
#

# Fills in the `<hash>`es of the given local package set, based on the contents
# of the package JSON files.
function local-packages-fill-in-hashes {
    local localPackageSet="$1"

    local jsonFiles=($(jget --output=raw "${localPackageSet}" '.[] | .destJsonFile'))
    local f
    for f in "${jsonFiles[@]}"; do
        jget --file="${f}" \
            '{
                name: (.name | sub("^@[^/]+/(?<name>.*)$"; .name)),
                hash: .shasum[0:20]
            }'
    done \
    | jval --input=slurp result:json="${localPackageSet}" \
        'reduce .[] as $item ($result;
            .[$item.name].destPkgFile =
                (.[$item.name].destPkgFile | sub("<hash>"; $item.hash))
            |
            .[$item.name].destPkgUri =
                (.[$item.name].destPkgUri | sub("<hash>"; $item.hash))
        )'
}

# Gets the set of local packages, as a JSON object mapped from name to info
# objects. The result leaves the destination package file with a `<hash>` hole
# to be filled in.
function local-packages {
    local pkgDirName='local-pkg'
    local pkgSrcDir="${srcDir}/pkg"
    local srcPaths

    srcPaths=($(
        find "${pkgSrcDir}" -mindepth 2 -maxdepth 2 -name package.json \
            -exec dirname '{}' ';' \
            | sort
        ))

    (
        local p
        for p in "${srcPaths[@]}"; do
            jval \
                outCodeDir="${outCodeDir}" \
                pkgDirName="${pkgDirName}" \
                name="$(basename "${p}")" \
                srcPath="${p}" \
                '
                ($pkgDirName + "/" + $name) as $nameBase
                |
                ($nameBase + "-<hash>.tgz") as $pkgFile
                |
                {
                    ($name): {
                        name:         $name,
                        scopedName:   ("@this/" + $name),
                        srcPath:      $srcPath,
                        destDir:      ($outCodeDir + "/" + $pkgDirName),
                        destJsonFile: ($outCodeDir + "/" + $nameBase + ".json"),
                        destPkgFile:  ($outCodeDir + "/" + $pkgFile),
                        destPkgUri:   ("file:" + $pkgFile)
                    }
                }'
        done
    ) | jval --input=slurp 'reduce .[] as $item ({}; . + $item)'
}

# Packs all the local packages.
function pack-local-packages {
    local localPackageSet="$1"

    progress-msg "Packing local packages:"

    local allNames=($(jget --output=raw "${localPackageSet}" 'keys | .[]'))
    local n
    for n in "${allNames[@]}"; do
        progress-msg "  ${n}"

        local paths="$(jget "${localPackageSet}" name="${n}" '.[$name]')"
        local destDir="$(jget --output=raw "${paths}" '.destDir')"

        mkdir -p "${destDir}" || return "$?"

        cd "$(jget --output=raw "${paths}" '.srcPath')"

        local packageInfo
        packageInfo="$(npm pack --json --pack-destination="${destDir}")" \
        || exit "$?"

        # The JSON output from `npm pack` is wrapped in a top-level array
        # (because some invocations can emit multiple packages), but it's
        # superfluous here, so we unwrap with `.[0]`.
        packageInfo="$(jget "${packageInfo}" '.[0]')"

        cat <<<"${packageInfo}" >"$(jget --output=raw "${paths}" '.destJsonFile')"
    done
}

# Renames the local packages to their designated hash-based name.
function rename-local-packages {
    local localPackageSet="$1"

    progress-msg "Moving local packages:"

    local allNames=($(jget --output=raw "${localPackageSet}" 'keys | .[]'))
    local n
    for n in "${allNames[@]}"; do
        progress-msg "  ${n}"

        local paths="$(jget "${localPackageSet}" name="${n}" '.[$name]')"
        local pkgFrom="$(jget --output=raw "${paths}" '.destDir')/"

        pkgFrom+="$(jget --output=raw \
            --file="$(jget --output=raw "${paths}" '.destJsonFile')" \
            '
            .filename
            |
            sub("^@(?<scope>[^/]+)/(?<name>.*)$"; .scope + "-" + .name)
            '
        )"

        mv "${pkgFrom}" "$(jget --output=raw "${paths}" '.destPkgFile')" \
        || return "$?"
    done
}

# Sets up the output directory.
function set-up-out-dir {
    local extraOpts=()
    if (( doClean )); then
        extraOpts=(--remove)
    fi

    lib out-dir --out="${outDir}" --create --print "${extraOpts[@]}"
}

# Tidies things up after a successful build. Specifically, removes local
# packages and package info files that aren't used (anymore) by the build.
function tidy-up {
    local localPackageSet="$1"

    # Cheesy tactic used here: We combine the lists of "things that are used"
    # and "all the things" into a single sorted/counted list. If an item shows
    # up twice (it's in both lists), then it's used. If it only shows up once,
    # it's defunct and should be removed.

    local usedFiles=($(
        jget --output=raw "${localPackageSet}" \
            'to_entries[] | .value.destJsonFile, .value.destPkgFile'
    ))

    local dirs=($(
        for d in "${usedFiles[@]}"; do
            dirname "${d}"
        done \
        | sort | uniq
    ))

    local defunct=($(
        (
            printf '%s\n' "${usedFiles[@]}"
            find "${dirs[@]}" -type f
        ) \
        | sort | uniq -c | awk '$1 != 2 { print $2 }'
    ))

    if (( ${#defunct[@]} != 0 )); then
        progress-msg 'Removing defunct local package files:'
        for d in "${defunct[@]}"; do
            progress-msg "  $(basename "${d}")"
            rm -f "${d}"
        done
    fi
}

# Old version of the JS build. TODO: Retire this!
function do-js-build-old {
    # Copy the top-level code.
    progress-msg 'Copying top-level code...'
    (
        mkdir -p "${outCodeDir}"
        cd "${srcDir}"
        find . -name pkg -prune -o -type f -name '*.js' \
            -exec cp '{}' "${outCodeDir}/{}" ';'
    ) \
    || exit "$?"

    # Create package tarballs of each local package, and also gather up all the
    # info for putting in the top-level `dependencies`.

    localPackageSet="$(local-packages)" \
    || exit "$?"

    pack-local-packages "${localPackageSet}" \
    || exit "$?"

    localPackageSet="$(local-packages-fill-in-hashes "${localPackageSet}")" \
    || exit "$?"

    rename-local-packages "${localPackageSet}" \
    || exit "$?"

    # Save the local package info for ease of human reference.
    cat <<<"${localPackageSet}" >"${outCodeDir}/local-pkg.json"

    # Prep for and then run `npm install`.

    # Derive the `dependencies` to use in the top-level `package.json` to
    # represent the local packages.
    localDepsObj="$(jget "${localPackageSet}" \
        'with_entries(.key = .value.scopedName | .value = .value.destPkgUri)'
    )"

    # Copy over main `package.json`, adding the local package dependencies.
    jget >"${outCodeDir}/package.json" \
        --file="${srcDir}/package.json" \
        deps:json="${localDepsObj}" \
        '.dependencies += $deps'

    # Let `npm` do its thing.

    progress-msg 'Fetching and installing dependencies...'

    cd "${outCodeDir}"
    npmOpts=(--no-fund --omit=dev)
    npm install "${npmOpts[@]}" \
    || exit "$?"

    # Check for files installed by `npm` that seem "suspect" for a
    # cross-platform build.
    cd "${outCodeDir}/node_modules"
    suspectFiles="$(
        find . -type f \
            '!' '(' \
                -name '*.js' -o -name '*.json' -o -name '*.html' -o -name '*.md' \
            ')' \
            -exec file '{}' ';' \
        | grep -Ev 'ASCII|JSON|PNG|UTF-8|empty|short file' \
        | awk '{ sub(/^\.\//, "  "); sub(/:[ \t].*$/, ""); print; }'
    )"
    if [[ ${suspectFiles} != '' ]]; then
        error-msg 'Files possibly containing platform-specific binaries:'
        error-msg -- "${suspectFiles}"
        exit 1
    fi

    # Denoument.

    # Clean things up a bit.
    tidy-up "${localPackageSet}" \
    || exit "$?"
}

# New version of the JS build. TODO: Clean this and the old stuff up.
function do-js-build-new {
    local projectName="$1"
    local mainModule="$2"
    local destDir="${outDir}/${projectName}"

    progress-msg 'Doing new-style JS build...'

    mkdir -p "${destDir}/main" \
    || return "$?"

    # Figure out local vs. external dependencies.

    progress-msg 'Finding local and external dependencies...'

    local deps
    deps="$(lib find-module-dependencies "${mainModule}")" \
    || return "$?"

    # Construct a top-level package.json.

    progress-msg 'Making `package.json`...'

    jget >"${destDir}/package.json" \
        --file="${srcDir}/pkg/${mainModule}/package.json" \
        deps:json="${deps}" \
        projectName="${projectName}" '
    . | del(.imports) +
    {
        name:         ("top-of-" + $projectName),
        dependencies: $deps.extDeps,
        exports:      "./main/index.js"
    }'

    # Write a top-level `index.js`.

    progress-msg 'Making `index.js`...'

    (
        for (( n = 0; n < 10; n++ )); do
            echo "// FILE GENERATED BY SCRIPT \`$(this-cmd-name)\`. DO NOT EDIT!"
        done
        echo ''
        echo "import { default as main } from '@this/${mainModule}';"
        echo ''
        echo 'await main();'
        echo ''
        echo '// `main()` is not expected to ever return.'
        echo $'throw new Error(\'Shouldn\\\'t happen.\');'
    ) > "${destDir}/main/index.js"

    # Copy all the local modules.
    #
    # Note: The `jget` command outputs an `eval`able script to perform the
    # copies.

    progress-msg 'Copying local modules...'

    local moduleFromDir="${srcDir}/pkg"
    local moduleToDir="${destDir}/main/node_modules"
    local copyCmd
    copyCmd="$(
        jget --output=raw "${deps}" \
            cmd='rsync-archive' \
            fromDir="${moduleFromDir}" \
            toDir="${moduleToDir}" '
        .localDeps
        |
        map({
                fromPath: ($fromDir + "/" + (. | sub("^[^/]*/"; "") + "/") | @sh),
                toPath:   ($toDir + "/" + . | @sh)
            }
            |
            "mkdir -p " + .toPath,
            $cmd + " " + .fromPath + " " + .toPath
            |
            "&& " + . + " \\"
        )
        |
        "true \\\n" + join("\n")
        '
    )"

    eval "${copyCmd}"

    # Run `npm install`.

    progress-msg 'Fetching and installing external dependencies...'

    (
        # TODO: Figure out how to run safely. (E.g. fetch first and then run the
        # actual install in an environment with no networking.)
        cd "${destDir}"
        npm install --no-fund --omit=dev
    ) \
    || return "$?"

    # TODO: Run the "suspicious files" checker.
}

# Calls `rsync` so as to do an all-local (not actually remote) "archive" copy
# (preserving permissions, modtimes, etc.).
#
# Note: We use `rsync` and not `cp` (even though this is a totally local
# operation) because it has well-defined behavior when copying a tree on top of
# another tree and also knows how to create directories as needed.
#
# Note: Trailing slashes on source directory names are significant to `rsync`.
# This may be salient at some of the use sites.
function rsync-archive {
    # Prepend `./` to any argument that could be mistaken for a remote path
    # (i.e., when there's a `:` before the first `/`).
    local args=()
    local arg
    for arg in "$@"; do
        if [[ ${arg} =~ ^[^/]+: ]]; then
            args+=("./${arg}")
        else
            args+=("${arg}")
        fi
    done

    # **Note:** We turn off file-sameness checking, which is irrelevant for this
    # use and is furthermore counterproductive, in that it can cause a failure
    # to copy when two non-identical files happen to match in both size and
    # timestamp. (This has happened in practice. When running a build on a
    # freshly checked-out source tree, many many files have the same timestamps,
    # so only the file sizes come into play, and it's very easy to have a file
    # size coincidence.)
    rsync --archive --delete --ignore-times -- "${args[@]}"
}


#
# Main script
#

progress-msg --enable

baseDir="$(dirname "$(this-cmd-dir)")"
srcDir="${baseDir}/src"
etcDir="${baseDir}/etc"
outDir="$(set-up-out-dir)"
outCodeDir="${outDir}/code"

# Make sure there's a cert to use.
lib make-localhost-cert \
|| exit "$?"

# Copy over the script binaries.
progress-msg 'Copying script binaries...'
(
    rm -rf "${outDir}/bin"
    mkdir -p "${outDir}/bin"
    cd "${etcDir}/bin-src"
    find . -type f '!' -name '*.md' \
        -exec cp '{}' "${outDir}/bin/{}" ';' \
        -exec chmod 755 "${outDir}/bin/{}" ';'
) \
|| exit "$?"

# Copy over the example setup.
progress-msg 'Copying example setup...'
(
    rm -rf "${outDir}/etc/example-setup"
    mkdir -p "${outDir}/etc"
    cp -r "${etcDir}/example-setup" "${outDir}/etc"
) \
|| exit "$?"

if (( doNew )); then
    do-js-build-new lactoserv main \
    || exit "$?"
else
    do-js-build-old \
    || exit "$?"
fi

progress-msg
progress-msg 'Build complete!'
