#!/bin/bash
#
# Copyright 2022 Dan Bornstein. All rights reserved.
# All code and assets are considered proprietary and unlicensed.

. "$(dirname "$(readlink -f "$0")")/lib/init.sh" || exit "$?"

#
# Argument parsing
#

function usage {
    print-usage $'
    Usage:

    ${name} [<opt> ...]
      Builds the project.

    --clean
      Do a clean build.
    --out=<dir>
      Directory where built output goes. Defaults to `out` directly under the
      main product directory.

    ${name} [--help | -h]
      Displays this message.
    '

    exit "$@"
}

# Want help?
opt-action --call='{ usage }' help/h

# Clean build?
opt-toggle --var=clean clean

# Built output directory.
opt-value --var=outDir out

process-args "$@" || usage "$?"


#
# Main script
#

progress-msg --enable

baseDir="$(dirname "$(this-cmd-dir)")"
srcDir="${baseDir}/src"
etcDir="${baseDir}/etc"

if [[ ${outDir} == '' ]]; then
    outDir="${baseDir}/out"
fi

if (( clean )); then
    lib clean --out="${outDir}" --create \
    || exit "$?"
else
    mkdir -p "${outDir}" \
    || exit "$?"
fi

# Copy the top-level code.
(
    progress-msg 'Copying top-level code...'
    cd "${srcDir}"
    find . -name pkg -prune -o -type f -name '*.js' -exec \
        cp '{}' "${outDir}/{}" ';'
)

# Create tarballs of each local package, and also gather up all the info for
# putting in the top-level `dependencies`.

packageDirName='local-pkg'
packageSrcDir="${srcDir}/pkg"
packageDestDir="${outDir}/${packageDirName}"
localDependencies=()
localPackages=($(
    cd "${packageSrcDir}"
    find . -mindepth 2 -maxdepth 2 -name package.json | awk -F/ '{ print $2 }' | sort
))

mkdir -p "${packageDestDir}"

for p in "${localPackages[@]}"; do
    progress-msg "Packing local package ${p}..."

    cd "${packageSrcDir}/${p}"
    jsonFile="${packageDestDir}/${p}.json"

    packageInfo="$(
        npm pack --json --pack-destination="${packageDestDir}"
    )" \
    || exit "$?"

    # The JSON output from `npm pack` is wrapped in a top-level array (because
    # some invocations can emit multiple packages), but it's superfluous here,
    # so unwrap with `.[0]`.
    packageInfo="$(jget "${packageInfo}" \
        dir="${packageDirName}" \
        '
            .[0]
            |
            ("file:" + $dir + "/") as $dirPrefix
            |
            .filename = (
                .filename
                    | sub("^@(?<scope>[^/]+)/(?<name>.*)$"; .scope + "-" + .name)
            )
            |
            .hashname = (
                (.name | sub("^@[^/]+/(?<name>.*)$"; .name)) + "-" +
                .shasum[0:20] + ".tgz"
            )
            |
            .dependencyEntry = { (.name): ($dirPrefix + .hashname) }
        '
    )" \
    || exit "$?"

    cat <<<"${packageInfo}" >"${jsonFile}"

    localDependencies+=("$(jget "${packageInfo}" '.dependencyEntry')")

    # Give the package a name- and hash-based file name. This keeps `npm`
    # happier, in that it will properly install changed local packages
    # instead of pulling the stale code from its cache.
    cd "${packageDestDir}"
    mv "$(jget --output=raw "${packageInfo}" '.filename')" \
        "$(jget --output=raw "${packageInfo}" '.hashname')" \
    || exit "$?"
done

# Copy over main `package.json`, adding a top-level dependency on each of the
# local packages, pointing to the tarballs we just made.

# Combine local dependencies into a single object.
localDepsObj="$(jget "$(jarray "${localDependencies[@]}")" \
    'reduce .[] as $item ({}; . + $item)'
)"

# Inject the dependencies!
jget >"${outDir}/package.json" \
    --file="${srcDir}/package.json" \
    deps:json="${localDepsObj}" \
    '.dependencies += $deps'

# Let `npm` do its thing.
progress-msg 'Fetching and installing dependencies...'
cd "${outDir}"
npm install --omit=dev \
|| exit "$?"

# Copy over the script binaries.
progress-msg 'Copying script binaries...'
mkdir -p "${outDir}/bin"
cd "${etcDir}/bin-src"
find . -type f \
    -exec cp '{}' "${outDir}/bin/{}" ';' \
    -exec chmod 755 "${outDir}/bin/{}" ';' \
|| exit "$?"

# Clean things up a bit.

# Remove defunct package info files. Kinda cheesy: Take the list of currently-
# valid names and the list of all the ones that are in the package output
# directory, and remove all of the names that don't appear twice.
defunct=($(
    (
        printf '%s\n' "${localPackages[@]}"
        find "${packageDestDir}" -name '*.json' -exec basename '{}' '.json' ';'
    ) | sort | uniq -c | awk '$1 != 2 { print $2 }'
))
for d in "${defunct[@]}"; do
    progress-msg "Removing defunct local package info for ${d}..."
    rm -f "${packageDestDir}/${d}.json"
done

# Remove defunct local package `tgz` files. Similar -- and similarly cheesy --
# logic to the package info file cleanup above.
defunct=($(
    (
        for p in "${localPackages[@]}"; do
            jget --file="${packageDestDir}/${p}.json" --output=raw '.hashname'
        done
        find "${packageDestDir}" -name '*.tgz' -exec basename '{}' ';'
    ) | sort | uniq -c | awk '$1 != 2 { print $2 }'
))
for d in "${defunct[@]}"; do
    progress-msg "Removing defunct local package ${d}..."
    rm -f "${packageDestDir}/${d}"
done

progress-msg
progress-msg 'Build complete!'
