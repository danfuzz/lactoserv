#!/bin/bash
#
# Copyright 2022-2023 the Bashy-lib Authors (Dan Bornstein et alia).
# SPDX-License-Identifier: Apache-2.0

. "$(dirname "$(readlink -f "$0")")/init.sh" || exit "$?"


#
# Argument parsing
#

define-usage $'
    ${name} [<opt> ...] [--] <command>

    Lists all the subcommands (and sub-subcommands, etc.) of the given
    command.

    ${name} [--help | -h]

    Displays this message.
'

# Want help?
opt-action --call='{ usage; exit }' help/h

# The command to print stuff about.
positional-arg --required --var=cmdName --filter='/^[a-z]/' command

process-args "$@" || usage --short


#
# Helper functions
#


#
# Main script
#

# Split the command into words, and keep the last word for later.
cmdWords=(${cmdName})
cmdName="${cmdName##* }"

cmdPath="$(lib --path "${cmdWords[@]}")" \
|| exit "$?"

# Derive the directory that the main command is in, including walking back from
# a `_run`.
if [[ ${cmdPath} =~ ^(.*)/[^/]+/_run$ ]]; then
    cmdDir="${BASH_REMATCH[1]}"
else
    cmdDir="${cmdPath%/*}"
fi

cmds=($(
    cd "${cmdDir}"
    # Non-obvious: `+ugo+x` just means _an_ execute bit is on, which is
    # necessary but not sufficient. We still need to check that the command is
    # actually executable by the user running this script.
    find "${cmdName}" -type f -perm +ugo+x
)) \
|| {
    error-msg "Command not found: ${cmdName}"
    exit 1
}

lines=()
for c in "${cmds[@]}"; do
    if [[ -x "${cmdDir}/${c}" ]]; then
        if [[ ${c} =~ ^(.*)/_run$ ]]; then
            c="${BASH_REMATCH[1]}"
        fi
        c="${c//\// }" # Replace slashes with spaces.
        lines+=("${c}")
    fi
done

printf '%s\n' "${lines[@]}" \
| sort
