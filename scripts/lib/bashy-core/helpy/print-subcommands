#!/bin/bash
#
# Copyright 2022-2023 the Bashy-lib Authors (Dan Bornstein et alia).
# SPDX-License-Identifier: Apache-2.0

. "$(dirname "$(readlink -f "$0")")/_init.sh" || exit "$?"


#
# Argument parsing
#

define-usage $'
    ${name} [<opt> ...] [--] <command> [<subcommand> ...]

    Lists all the subcommands (and sub-subcommands, etc.) of the given
    command.

    ${name} [--help | -h]

    Displays this message.
'

# Want help?
opt-action --call='{ usage; exit }' help/h

# The command to print stuff about.
positional-arg --required --var=cmdName --filter='/^[a-z]/' command

# Subcommands if any.
rest-arg --var=subWords --filter='/^[a-z]/' subcommands

process-args "$@" || usage --short


#
# Helper functions
#


#
# Main script
#

# Unify all the words.
cmdWords=("${cmdName}" "${subWords[@]}")

cmdPath="$(lib --path "${cmdWords[@]}")" \
|| exit "$?"

if [[ -f "${cmdPath}" ]]; then
    # We found a regular command script, not a directory.
    error-msg "No subcommands found: ${cmdWords[@]}"
    exit 1
fi

cmds=($(
    cd "${cmdPath}"
    # Non-obvious: `+ugo+x` just means _an_ execute bit is on, which is
    # necessary but not sufficient. We still need to check that the command is
    # actually executable by the user running this script.
    find . -type f -perm +ugo+x
)) \
|| {
    error-msg "No subcommands found: ${cmdWords[@]}"
    exit 1
}

lines=("${cmdWords[*]}")
for c in "${cmds[@]}"; do
    if [[ -x "${cmdPath}/${c}" ]]; then
        if [[ ${c} =~ ^(.*)/_run$ ]]; then
            c="${BASH_REMATCH[1]}"
        fi
        c="${c#./}"    # Drop the initial `./`.
        c="${c//\// }" # Replace slashes with spaces.
        lines+=("${cmdWords[*]} ${c}")
    fi
done

printf '%s\n' "${lines[@]}" \
| sort
