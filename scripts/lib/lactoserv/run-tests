#!/bin/bash
#
# Copyright 2022-2024 the Lactoserv Authors (Dan Bornstein et alia).
# SPDX-License-Identifier: Apache-2.0

. "$(dirname "$(readlink -f "$0")")/_init.sh" || exit "$?"


TOOL_DEPENDENCIES='{
    "jest": "^29.0.3",
    "jest-extended": "^3.1.0",
    "jest-light-runner": "^0.4.0",
    "trace-unhandled": "^2.0.1"
}'


#
# Argument parsing
#

define-usage --with-help $'
    ${name} [<opt> ...] <test-arg> ...

    Runs the unit test system.

    --do=<action>
      `build` -- Always build, even if there is something already built.
      `clean` -- Always do a clean build.
      `run` -- Build only if there is nothing yet built. This is the default.
    --type=<type> :: `integration` `unit`
      Test type to run. By default, runs unit tests.
    --out=<dir>
      Directory where built output goes. Defaults to `out` directly under the
      main product directory.
'

# What to do?
opt-value --var=action --default=run --enum[]='build clean run' do

# Test type.
opt-value --var=testType --enum[]='integration unit' type

# Built output directory.
opt-value --var=outDir out

# Arbitrary args to pass to the tool.
rest-arg --var=args args

process-args "$@" || exit "$?"


#
# Helper functions
#

# Performs a build if necessary / requested.
function build-if-necessary {
    local action="$1"

    local buildCmd=(lib build --out="${outDir}")
    local doBuild=0

    case "${action}" in
        build)
            doBuild=1
            ;;
        clean)
            buildCmd+=(--clean)
            doBuild=1
            ;;
        run)
            if [[ ! -x "${outDir}/lactoserv/lib/code/node_modules" ]]; then
                doBuild=1
            fi
            ;;
    esac

    if (( doBuild )); then
        progress-msg 'Building...'
        "${buildCmd[@]}" || return "$?"
        progress-msg
        progress-msg 'Running...'
        progress-msg
    fi

}

# Finds a hopefully-unique file at the top level of the project whose name has
# the right prefix. Prints it.
function config-file-path {
    local configFile

    configFile=($(
        lib ls-files --output=lines \
            --cd="${srcDir}" --full-paths --depth=1 --include='^jest\.config\.'
    )) \
    || return "$?"

    if (( ${#configFile[@]} != 1 )); then
        if (( ${#configFile[@]} == 0 )); then
            error-msg 'Did not find a Jest config file in the project!'
        else
            error-msg 'Did not find a _unique_ Jest config file!'
        fi
        return 1
    fi

    echo "${configFile[0]}"
}

# Runs integration tests.
function run-integration-tests {
    "$(base-dir)/tests/run-all" "${args[@]}"
}

# Runs unit tests.
function run-unit-tests {
    local configFile
    configFile="$(config-file-path)" \
    || exit "$?"

    local toolPath
    toolPath="$(tester-path)" \
    || exit "$?"

    # Find the tests, and generally set up the testing directory.

    local testsDir="${outDir}/tests"

    rm -rf "${testsDir}"
    mkdir -p "${testsDir}"
    cd "${testsDir}"
    rm -rf node_modules
    ln -s ../lactoserv/lib/code/node_modules .
    echo >package.json '{ "type": "module" }'

    # TODO: Try this to see if Pulsar and/or Zed still mess up syntax highlighting.
    #cat >package.json <<< '{ "type": "module" }'

    local dirsWithTests
    dirsWithTests="$(
        lib ls-files --output=array --cd="${srcDir}" --dirs --full-paths \
            --include='/tests$')" \
    || exit "$?"

    while IFS='' read -r -d $'\0' dir; do
        [[ ${dir} =~ /([^/]+)/tests$ ]] || {
            error-msg "Weird directory name: ${dir}"
            exit 1
        }

        local moduleName="${BASH_REMATCH[1]}"
        cp -r "${dir}" "${testsDir}/${moduleName}"
    done < <(jget --output=raw0 "${dirsWithTests}" '.[]')

    # Copy the config file into place, where it will be found when the test
    # harness is run.
    cp "${configFile}" "${testsDir}"
    configFile="${testsDir}/$(basename "${configFile}")"

    # Run the tool!

    "${toolPath}" --config="${configFile}" "${args[@]}" \
    || return "$?"
}

# Builds the tester if necessary, and then prints the path to it main binary.
function tester-path {
    local toolModule=tester
    local toolDir="${outDir}/${toolModule}"
    local toolPath="${toolDir}/bin/tester"

    # Build the tester, if necessary.
    if [[ ! -x ${toolPath} ]]; then
        lib 1>&2 node-project build-main-module \
            --allow-platform-specific-files \
            --out="${outDir}" --modules-dirs="${srcDir}" "${toolModule}" \
        || return "$?"
    fi

    echo "${toolPath}"
}


#
# Main script
#

srcDir="$(base-dir)/src"
outDir="$(lib buildy out-dir --out="${outDir}")" \
|| exit "$?"

build-if-necessary "${action}" \
|| exit "$?"

if [[ ${testType} == integration ]]; then
    run-integration-tests
else
    run-unit-tests
fi

status="$?"

info-msg

if (( ${status} == 0 )); then
    info-msg 'No errors! Yay!'
else
    error-msg --no-name 'Errors. Alas.'
    exit "${status}"
fi
