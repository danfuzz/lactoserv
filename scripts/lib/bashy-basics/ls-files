#!/bin/bash
#
# Copyright 2022-2023 the Bashy-lib Authors (Dan Bornstein et alia).
# SPDX-License-Identifier: Apache-2.0

. "$(dirname "$(readlink -f "$0")")/_init.sh" || exit "$?"


#
# Argument parsing
#

define-usage $'
    ${name} [<path> ...]

    List files and/or directories at or under the given <path>s. With no <path>s,
    lists all items in or under the current directory.

    This tool is inspired by `git ls-files`, and is similar to the git-specific
    `buildy ls-files` in this library.

    --cd=<dir>
      Change to the given directory before performing the search. This affects
      how relative <path>s are treated as well as passing no <path> arguments
      at all.
    --depth=<n>
      Only include paths at the given depth below the starting <path>s.
    --dirs
      Include directories in the output.
    --exclude=<regex>
      Regular expression indicating which files to exclude. This is treated as
      an "extended" regex. If both this and `--include` are used, then this
      option takes precedence.
    --files
      Include files in the output. This is the default if neither this option nor
      `--dirs` is specified.
    --full-paths
      Output full canonicalized (absolute) paths. By default, outputs paths that
      are prefixed with one of the <path> arguments, or in the case of no <path>
      arguments not prefixed at all (just a straight relative path from CWD).
    --include=<regex>
      Regular expression indicating which files to include. This is treated as
      an "extended" regex.
    --output=<style> :: `json` `lines` `raw0`
      * `json` -- Output a JSON array of all file paths. This is the default.
      * `lines` -- Output newline-terminated file paths.
      * `raw0` -- Output NUL-terminated file paths.

    ${help}
'

# Want help?
opt-action --call='{ usage; exit }' help/h

# Directory to `cd` to before running.
opt-value --var=cdTo --filter='/./' cd

# Depth for results.
opt-value --var=depth --filter='/^[0-9]+$/' depth

# Exclude pattern.
opt-value --var=excludeRegex --filter='/./' exclude

# Include directories in the output?
opt-toggle --var=doDirs dirs

# Include (regular) files in the output?
opt-toggle --var=doFiles files

# Full paths?
opt-toggle --var=fullPaths full-paths

# Include pattern.
opt-value --var=includeRegex --filter='/./' include

# Output style.
opt-value --var=outputStyle --init=json --enum='json lines raw0' output

# The paths.
rest-arg --var=paths --filter='/./' paths

process-args "$@" || usage --short


#
# Main script
#

if (( !doDirs )); then
    doFiles=1
fi

if [[ ${cdTo} != '' ]]; then
    cd "${cdTo}" \
    || exit "$?"
fi

impliedCwd=0
if [[ ${#paths[@]} == 0 ]]; then
    paths=('.')
    impliedCwd=1
fi

results=()

while IFS='' read -r -d $'\0' file; do
    if [[ ${file} == $'\x01error' ]]; then
        exit 1
    fi

    if (( impliedCwd )); then
        if [[ ${file} == '.' ]]; then
            # Drop the top-level `.` entirely.
            continue
        else
            # Drop the `./` prefix from the result.
            file="${file#'./'}"
        fi
    fi

    # Process exclusions and inclusions, if any.
    if [[ (${excludeRegex} != '') && (${file} =~ ${excludeRegex}) ]]; then
        continue
    elif [[ (${includeRegex} != '') && !(${file} =~ ${includeRegex}) ]]; then
        continue
    fi

    if (( fullPaths )); then
        file="$(readlink -f "${file}")" \
        || exit 1
    fi

    results+=("${file}")
done < <(
    findArgs=("${paths[@]}")

    if [[ ${depth} != '' ]]; then
        findArgs+=(-mindepth "${depth}" -maxdepth "${depth}")
    fi

    if (( doFiles )); then
        if (( doDirs )); then
            findArgs+=('(' -type f -o -type d ')')
        else
            findArgs+=(-type f)
        fi
    elif (( doDirs )); then
        findArgs+=(-type d)
    fi

    # Note: The `printf` contents are designed to make it possible for the loop
    # above to (nearly) unambiguously notice errors.
    find "${findArgs[@]}" -print0 \
    || printf '\x01error\x00'
)

case "${outputStyle}" in
    json)
        jarray --input=strings "${results[@]}"
        ;;
    lines)
        printf '%s\n' "${results[@]}"
        ;;
    raw0)
        printf '%s\x00' "${results[@]}"
        ;;
esac
