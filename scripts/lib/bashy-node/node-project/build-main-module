#!/bin/bash
#
# Copyright 2022-2023 the Bashy-lib Authors (Dan Bornstein et alia).
# SPDX-License-Identifier: Apache-2.0

. "$(dirname "$(readlink -f "$0")")/_init.sh" || exit "$?"


#
# Argument parsing
#

define-usage $'
    ${name} [<opt> ...] <project-name>

    Builds a Node main module, pulling in all its local dependencies. The
    result is deposited in a directory named <project-name> under the output
    directory. The module used to build this is named `@this/main-<project-name>`
    which is expected to be present in the modules directory.

    --allow-platform-specific-files
      If specified, the build does *not* check to see if any platform-specific
      files ended up in the built output.
    --modules-dir=<dir>
      Directory containing all source modules. Required. *Note:* Each of the
      modules is expected to be defined to have the name `@this/<name>` where
      <name> names the directory the module is in.
    --out=<dir>
      Directory where built output goes. Defaults to `out` directly under the
      main product directory.
    --unsafely-run-npm-install-scripts
      If specified, runs any install-time scripts defined by modules. This is
      reasonably considered an unsafe practice (it is a vector for
      developer-directed malware), which is why it is disabled by default. This
      option exists to enable tactical problem-solving, with the hope that it
      will be left on only ephemerally.

    ${help}
'

# Want help?
opt-action --call='{ usage; exit }' help/h

# Allow the build to be platform-specific?
opt-toggle --var=platformSpecific allow-platform-specific-files

# Directory containing all the modules.
opt-value --required --var=modulesDir --filter='/./' modules-dir

# Built output directory.
opt-value --var=outDir out

# Run npm install-time scripts?
opt-toggle --var=runNpmInstallScripts unsafely-run-npm-install-scripts

# Project name.
positional-arg --filter='/^[-a-z0-9]+$/' --var=projectName project-name

process-args "$@" || usage --short


#
# Helper functions
#

# The main actions of this script.
function build-project {
    local projectName="$1"
    local modulesDir="$2"
    local destDir="$3"

    local destLibDir="${destDir}/lib"
    local mainModule="main-${projectName}"
    local srcMainModule="${modulesDir}/${mainModule}"
    local srcPackageJson="${srcMainModule}/package.json"
    local srcPackageLockJson="${srcMainModule}/package-lock.json"
    local localCodeDirName='code'
    local destLocalCode="${destLibDir}/${localCodeDirName}"
    local destLocalModules="${destLocalCode}/node_modules"

    progress-msg "Main module: ${mainModule}"

    mkdir -p "${destLocalModules}" \
    || return "$?"

    # Figure out local vs. external dependencies.

    progress-msg 'Determining local and external dependencies...'

    local deps
    deps="$(
        lib . find-module-dependencies \
            --modules-dir="${modulesDir}" "${mainModule}"
    )" \
    || return "$?"

    # Construct a top-level package.json.

    progress-msg 'Making `package.json` and `product-info.json`...'

    jget >"${destLibDir}/package.json" \
        --file="${srcPackageJson}" \
        localCodeDirName="${localCodeDirName}" \
        deps:json="${deps}" \
        projectName="${projectName}" '
    . | del(.imports) +
    {
        name:         ("top-of-" + $projectName),
        dependencies: $deps.extDeps,
        exports:      ("./" + $localCodeDirName + "/index.js")
    }' \
    || return "$?"

    jval >"${destDir}/product-info.json" \
        commitInfo="$(commit-info)" \
        projectName="${projectName}" \
        srcPackage:json:file="${srcPackageJson}" '
    {
        name: $projectName,
        version: $srcPackage.version,
        commit: $commitInfo
    }' \
    || return "$?"

    if [[ -f "${srcPackageLockJson}" ]]; then
        progress-msg 'Copying `package-lock.json`...'
        cp "${srcPackageLockJson}" "${destLibDir}/package-lock.json"
    fi

    true \
    && make-index-js "${destLocalCode}" \
    && copy-scripts "${srcMainModule}" "${destDir}" \
    && copy-local-modules "${destLocalModules}" "${deps}" \
    && remove-dead-local-modules "${destLocalModules}" "${deps}" \
    && npm-install "${destLibDir}" \
    || return "$?"

    cp "${destLibDir}/package-lock.json" "${srcPackageLockJson}"
}

# Figures out the pithy commit info to associate with the build.
function commit-info {
    cd "$(base-dir)"

    if [[ ! -d ".git" ]]; then
        echo '<unknown>'
        return
    fi

    local infoWords
    infoWords=("$(git rev-parse --short=8 HEAD)") \
    || return "$?"

    infoWords+=($(git tag --points-at HEAD)) \
    || return "$?"

    echo "${infoWords[*]}"
}

# Copies all the local modules for a project.
function copy-local-modules {
    local moduleDestDir="$1"
    local deps="$2"

    progress-msg 'Copying local modules...'

    # The `jget` command outputs an `eval`able script to perform the copies,
    # which is immediately `eval`ed.

    local copyCmd
    copyCmd="$(
        jget --output=raw "${deps}" \
            cmd='lib rsync-local' \
            toDir="${moduleDestDir}" '
          .localDirs
        | to_entries
        | map({ name: .key, fromPath: .value })
        | map({
            fromPath: ("\(.fromPath)/" | @sh),
            toPath:   ("\($toDir)/\(.name)" | @sh)
        })
        | map(
            "mkdir -p " + .toPath,
            $cmd + " " + .fromPath + " " + .toPath
        )
        | map("&& " + . + " \\")
        | ["true \\"] + . + ["&& true"]
        | join("\n")
        '
    )" \
    || return "$?"

    eval "${copyCmd}"
}

# Copies the main module's script(s), if any.
function copy-scripts {
    local srcDir="$1/bin"
    local destDir="$2/bin"

    # Get a JSON array of all the files. `.[2:]` strips off the leading `./`.
    local fileList
    fileList="$(
        cd "${srcDir}"
        find . -mindepth 1 -maxdepth 1 -print0 \
        | jval --input=raw0:slurp 'map(.[2:])'
    )" \
    || return "$?"

    local flen="$(jget "${fileList}" 'length')"

    if (( flen == 0 )); then
        return;
    fi

    progress-msg 'Copying scripts...'

    mkdir -p "${destDir}" \
    || return "$?"

    local i f srcScript destScript
    for (( i = 0; i < flen; i++ )); do
        f="$(jget --output=raw "${fileList}" i:json="${i}" '.[$i]')"
        srcScript="${srcDir}/${f}"
        destScript="${destDir}/${f}"
        if [[ -x "${srcScript}" ]]; then
            error-msg 'Script is marked executable in the source directory:'
            error-msg "  ${srcScript}"
            error-msg 'It cannot actually be run from there. Do this:'
            error-msg
            error-msg --exec printf '  chmod -x %q\n' "${srcScript}"
            error-msg
            return 1
        fi
        progress-msg "  ${f}"
        rm -rf "${destScript}"            || return "$?"
        cp "${srcScript}" "${destScript}" || return "$?"
        chmod +x "${destScript}"          || return "$?"
    done
}

# Writes a top-level `index.js` for a project.
function make-index-js {
    local dir="$1"

    progress-msg 'Making `index.js`...'

    (
        for (( n = 0; n < 10; n++ )); do
            echo "// FILE GENERATED BY SCRIPT \`$(this-cmd-name)\`. DO NOT EDIT!"
        done
        echo ''
        echo "import { default as main } from '@this/${mainModule}';"
        echo ''
        echo 'await main();'
        echo ''
        echo '// `main()` is not ever supposed to return.'
        echo $'throw new Error(\'Shouldn\\\'t happen.\');'
        echo ''
        for (( n = 0; n < 10; n++ )); do
            echo "// FILE GENERATED BY SCRIPT \`$(this-cmd-name)\`. DO NOT EDIT!"
        done
    ) > "${dir}/index.js"
}

# Does an `npm install` in the given directory.
function npm-install {
    local dir="$1"

    progress-msg 'Fetching and installing external dependencies...'
    progress-msg

    local extraOpts=()
    if (( !runNpmInstallScripts )); then
        # `--ignore-scripts` is a tactic to avoid developer-targeted malware.
        # (See the note in the usage message above.) As of this writing, none of
        # the dependencies of any project using this system actually need to run
        # install scripts, so there's nothing additional to do in order to cope
        # with the flag (e.g., no need to run scripts in an "offline chroot" or
        # somesuch).
        extraOpts=(--ignore-scripts)
    fi

    (
        cd "${dir}"
        npm install --no-fund --omit=dev "${extraOpts[@]}"
    ) \
    || return "$?"
}

# Removes any local modules that are "dead" with respect to the current build.
# These are modules that (presumably) used to be part of the build but got
# dropped for whatever reason.
function remove-dead-local-modules {
    local dir="$1"
    local deps="$2"

    local deadModules
    deadModules="$(
        cd "${dir}"
        find . -mindepth 2 -maxdepth 2 -type d -print0 \
        | jval --input=raw0:slurp \
            deps:json="${deps}" \
            'map(ltrimstr("./")) - $deps.localDeps'
    )" \
    || return "$?"

    if [[ ${deadModules} != '[]' ]]; then
        # The following generates an `eval`able script to perform the removals.
        local removalCmd
        removalCmd="$(
            jval \
                --output=raw \
                dir="${dir}" \
                deadModules:json="${deadModules}" '
            $deadModules
            |
            map(
                "progress-msg " + ("  " + . | @sh),
                "rm -rf " + ($dir + "/" + . | @sh)
                |
                "&& " + . + " \\"
            )
            |
            ["true \\"] + . + ["&& true"]
            |
            join("\n")
        ')"

        progress-msg 'Removing defunct local modules:'

        eval "${removalCmd}"

        progress-msg
    fi
}

# Checks a `node_modules` directory (or similar) for "suspect" files, given a
# desire to have a platform-agnostic build.
function suspect-file-check {
    local dir="$1"

    if [[ ! -d ${dir} ]]; then
        error-msg 'Missing directory for suspect file check:'
        error-msg "  ${dir}"
        return 1
    fi

    suspectFiles="$(
        cd "${dir}"
        find . -type f \
            '!' '(' \
                -name '*.js' -o -name '*.json' -o -name '*.html' -o -name '*.md' \
            ')' \
            -exec file '{}' ';' \
        | grep -Ev 'ASCII|JSON|PNG|UTF-8|empty|short file' \
        | awk '{ sub(/^\.\//, "  "); sub(/:[ \t].*$/, ""); print; }'
    )"

    if (( $? != 0 )); then
        return 1
    fi

    if [[ ${suspectFiles} != '' ]]; then
        error-msg 'Files possibly containing platform-specific binaries:'
        error-msg -- "${suspectFiles}"
        return 1
    fi
}


#
# Main script
#

progress-msg "Building JS project ${projectName}..."

outDir="$(lib buildy out-dir --out="${outDir}" --create --print --quiet)"

outProjectDir="${outDir}/${projectName}"

if [[ ! -d ${outProjectDir} ]]; then
    progress-msg 'Creating project-specific output directory...'
    mkdir -p "${outProjectDir}" \
    || exit "$?"
fi

build-project "${projectName}" "${modulesDir}" "${outProjectDir}" \
|| exit "$?"

if (( !platformSpecific )); then
    progress-msg 'Checking for platform agnosticity...'
    suspect-file-check "${outProjectDir}/lib/node_modules" \
    || exit "$?"
fi

progress-msg
progress-msg "Built JS project ${projectName}."
