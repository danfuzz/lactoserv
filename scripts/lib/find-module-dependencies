#!/bin/bash
#
# Copyright 2022 Dan Bornstein.
# Licensed AS IS and WITHOUT WARRANTY under the Apache License, Version 2.0.
# Details: <http://www.apache.org/licenses/LICENSE-2.0>

# Load the helper libraries.
. "$(dirname "$(readlink -f "$0")")/init.sh" || exit "$?"

#
# Argument parsing
#

function usage {
    print-usage $'
    Usage:

    ${name} [<opt> ...] [--] <module-name>
      Transitively finds all module dependencies from the one given, which must
      be the name of a module defined in this codebase. Prints out a JSON object
      with bindings as follows:

      * `main: string` -- The originally requested module.
      * `localDeps: [name, ...]` -- Local module dependencies.
      * `extDeps: { name: version, ... }` -- External (e.g. npm) module
        dependencies.

    ${name} [--help | -h]
      Displays this message.
    '

    exit "$@"
}

# Want help?
opt-action --call='{ usage }' help/h

# The module to start at.
positional-arg --required --var=moduleName module-name

process-args "$@" || usage "$?"


#
# Main script
#

localModulesDir="$(base-dir)/src/pkg"

# Collect all of the modules referenced by this package, transitively including
# all referenced local modules. The result is two lists, one of local modules
# and one of regular (published via npm) dependencies. This uses a work queue
# arrangement where we start with the main subproject as the sole element of the
# to-be-processed queue.


state="$(jval mainModule="@this/${moduleName}" '{
    unprocessed: [],
    localDeps:   [],
    extDeps:     [],
    main:        $mainModule,
    next:        $mainModule
}')"

while true; do
    oneDep="$(jget --output=raw "${state}" '.next')"
    if [[ ${oneDep} == '<done>' ]]; then
        break;
    fi

    # Reminder: `${var##*/}` removes everything up to the last slash. In this
    # case, it's trimming `@this/` off of `oneDep`.
    pkgFile="${localModulesDir}/${oneDep##*/}/package.json"

    if [[ ! -r "${pkgFile}" ]]; then
        echo "Not readable: ${pkgFile}" 1>&2
        exit 1
    fi

    state="$(
        jget --file="${pkgFile}" \
            oneDep="${oneDep}" \
            state:json="${state}" '
        ((.dependencies // {}) | to_entries) as $allDeps
        |
        ($allDeps | map(select(.key | startswith("@this/")) | .key)) as $localDeps
        |
        ($allDeps | map(select(.key | startswith("@this/") | not) | .key + "@" + .value)) as $extDeps
        |
        {
            unprocessed: ($state.unprocessed + $localDeps),
            localDeps:   ($state.localDeps + [$oneDep]),
            extDeps:     ($state.extDeps + $extDeps)
        }
        |
        {
            unprocessed: (.unprocessed - .localDeps | unique),
            localDeps:   (.localDeps | unique),
            extDeps:     (.extDeps   | unique),
        }
        |
        $state + . + { next: (.unprocessed[0] // "<done>") }
        '
    )"
done

# Verify that there aren't two (or more) different versions listed for any
# single external dependency.

conflicts="$(jget "${state}" '
    .extDeps
    | map([(sub("@.*$"; "")), [.]])
    | reduce .[] as $item ({}; . + { ($item[0]): (.[$item[0]] + $item[1]) })
    | to_entries | map(select((.value | length) > 1)) | from_entries
')"

if [[ ${conflicts} != '{}' ]]; then
    error-msg 'Conflicting external module versions:'
    error-msg --exec jget "${conflicts}"
    exit 1
fi

# Form the final result.
jget "${state}" '{
    main,
    localDeps,
    extDeps:
        (.extDeps | map(split("@") | { key: .[0], value: .[1] }) | from_entries)
}'
